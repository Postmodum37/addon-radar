// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearRisingAgeForDroppedAddons = `-- name: ClearRisingAgeForDroppedAddons :exec
UPDATE trending_scores
SET first_rising_at = NULL
WHERE addon_id NOT IN (
    SELECT addon_id FROM trending_scores
    WHERE rising_score > 0
    ORDER BY rising_score DESC
    LIMIT 20
)
`

// Reset first_rising_at for addons that dropped out of rising list
func (q *Queries) ClearRisingAgeForDroppedAddons(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearRisingAgeForDroppedAddons)
	return err
}

const clearTrendingAgeForDroppedAddons = `-- name: ClearTrendingAgeForDroppedAddons :exec
UPDATE trending_scores
SET first_hot_at = NULL
WHERE addon_id NOT IN (
    SELECT addon_id FROM trending_scores
    WHERE hot_score > 0
    ORDER BY hot_score DESC
    LIMIT 20
)
`

// Reset first_hot_at for addons that dropped out of hot list
func (q *Queries) ClearTrendingAgeForDroppedAddons(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearTrendingAgeForDroppedAddons)
	return err
}

const countActiveAddons = `-- name: CountActiveAddons :one
SELECT COUNT(*) FROM addons WHERE status = 'active'
`

func (q *Queries) CountActiveAddons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveAddons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAddons = `-- name: CountAddons :one
SELECT COUNT(*) FROM addons WHERE status = 'active'
`

func (q *Queries) CountAddons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAddons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAddonsByCategory = `-- name: CountAddonsByCategory :one
SELECT COUNT(*) FROM addons
WHERE status = 'active'
  AND $1::int = ANY(categories)
`

func (q *Queries) CountAddonsByCategory(ctx context.Context, dollar_1 int32) (int64, error) {
	row := q.db.QueryRow(ctx, countAddonsByCategory, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllRecentFileUpdates = `-- name: CountAllRecentFileUpdates :many
SELECT
    addon_id,
    COUNT(DISTINCT DATE(latest_file_date))::int AS update_count
FROM snapshots
WHERE recorded_at >= NOW() - INTERVAL '90 days'
  AND latest_file_date IS NOT NULL
GROUP BY addon_id
`

type CountAllRecentFileUpdatesRow struct {
	AddonID     int32 `json:"addon_id"`
	UpdateCount int32 `json:"update_count"`
}

// Bulk count file updates for all addons
func (q *Queries) CountAllRecentFileUpdates(ctx context.Context) ([]CountAllRecentFileUpdatesRow, error) {
	rows, err := q.db.Query(ctx, countAllRecentFileUpdates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountAllRecentFileUpdatesRow{}
	for rows.Next() {
		var i CountAllRecentFileUpdatesRow
		if err := rows.Scan(&i.AddonID, &i.UpdateCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countHotAddons = `-- name: CountHotAddons :one
SELECT COUNT(*)
FROM addons a
JOIN trending_scores t ON a.id = t.addon_id
WHERE a.status = 'active'
  AND a.download_count >= 500
  AND t.hot_score > 0
`

func (q *Queries) CountHotAddons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countHotAddons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOldSnapshots = `-- name: CountOldSnapshots :one
SELECT COUNT(*) FROM snapshots
WHERE recorded_at < NOW() - INTERVAL '95 days'
`

// Count snapshots older than 95 days (for progress logging)
func (q *Queries) CountOldSnapshots(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOldSnapshots)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentFileUpdates = `-- name: CountRecentFileUpdates :one
SELECT COUNT(DISTINCT DATE(latest_file_date))
FROM snapshots
WHERE addon_id = $1
  AND recorded_at >= NOW() - ($2 || ' days')::INTERVAL
  AND latest_file_date IS NOT NULL
`

type CountRecentFileUpdatesParams struct {
	AddonID int32       `json:"addon_id"`
	Column2 pgtype.Text `json:"column_2"`
}

// Counts file updates in last N days (approximated by comparing latest_file_date changes in snapshots)
func (q *Queries) CountRecentFileUpdates(ctx context.Context, arg CountRecentFileUpdatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentFileUpdates, arg.AddonID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRisingAddons = `-- name: CountRisingAddons :one
SELECT COUNT(*)
FROM addons a
JOIN trending_scores t ON a.id = t.addon_id
WHERE a.status = 'active'
  AND a.download_count >= 50
  AND a.download_count <= 10000
  AND t.rising_score > 0
  AND a.id NOT IN (
      SELECT addon_id FROM trending_scores
      WHERE hot_score > 0
      ORDER BY hot_score DESC
      LIMIT 20
  )
`

func (q *Queries) CountRisingAddons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRisingAddons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchAddons = `-- name: CountSearchAddons :one
SELECT COUNT(*) FROM addons
WHERE status = 'active'
  AND (name ILIKE '%' || $1 || '%' OR summary ILIKE '%' || $1 || '%')
`

func (q *Queries) CountSearchAddons(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchAddons, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSnapshots = `-- name: CountSnapshots :one
SELECT COUNT(*) FROM snapshots
`

func (q *Queries) CountSnapshots(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSnapshots)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSnapshot = `-- name: CreateSnapshot :exec
INSERT INTO snapshots (addon_id, recorded_at, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date)
VALUES ($1, NOW(), $2, $3, $4, $5, $6)
`

type CreateSnapshotParams struct {
	AddonID        int32              `json:"addon_id"`
	DownloadCount  int64              `json:"download_count"`
	ThumbsUpCount  pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank pgtype.Int4        `json:"popularity_rank"`
	Rating         pgtype.Numeric     `json:"rating"`
	LatestFileDate pgtype.Timestamptz `json:"latest_file_date"`
}

func (q *Queries) CreateSnapshot(ctx context.Context, arg CreateSnapshotParams) error {
	_, err := q.db.Exec(ctx, createSnapshot,
		arg.AddonID,
		arg.DownloadCount,
		arg.ThumbsUpCount,
		arg.PopularityRank,
		arg.Rating,
		arg.LatestFileDate,
	)
	return err
}

const deleteOldRankHistory = `-- name: DeleteOldRankHistory :execrows
DELETE FROM trending_rank_history
WHERE recorded_at < NOW() - INTERVAL '8 days'
`

// Delete rank history older than 8 days (1-day buffer for 7-day lookback queries)
func (q *Queries) DeleteOldRankHistory(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldRankHistory)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldSnapshotsBatch = `-- name: DeleteOldSnapshotsBatch :execrows
DELETE FROM snapshots
WHERE id IN (
    SELECT id FROM snapshots
    WHERE recorded_at < NOW() - INTERVAL '95 days'
    ORDER BY id
    LIMIT $1
)
`

// Delete snapshots older than 95 days in batches to avoid long-running transactions
// Use ORDER BY id for consistent batching (faster than ORDER BY recorded_at)
func (q *Queries) DeleteOldSnapshotsBatch(ctx context.Context, limit int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldSnapshotsBatch, limit)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAddonByID = `-- name: GetAddonByID :one
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons WHERE id = $1
`

func (q *Queries) GetAddonByID(ctx context.Context, id int32) (Addon, error) {
	row := q.db.QueryRow(ctx, getAddonByID, id)
	var i Addon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Summary,
		&i.AuthorName,
		&i.AuthorID,
		&i.LogoUrl,
		&i.PrimaryCategoryID,
		&i.Categories,
		&i.GameVersions,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.LastSyncedAt,
		&i.IsHot,
		&i.HotUntil,
		&i.Status,
		&i.DownloadCount,
		&i.ThumbsUpCount,
		&i.PopularityRank,
		&i.Rating,
		&i.LatestFileDate,
	)
	return i, err
}

const getAddonBySlug = `-- name: GetAddonBySlug :one
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons WHERE slug = $1 AND status = 'active'
`

func (q *Queries) GetAddonBySlug(ctx context.Context, slug string) (Addon, error) {
	row := q.db.QueryRow(ctx, getAddonBySlug, slug)
	var i Addon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Summary,
		&i.AuthorName,
		&i.AuthorID,
		&i.LogoUrl,
		&i.PrimaryCategoryID,
		&i.Categories,
		&i.GameVersions,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.LastSyncedAt,
		&i.IsHot,
		&i.HotUntil,
		&i.Status,
		&i.DownloadCount,
		&i.ThumbsUpCount,
		&i.PopularityRank,
		&i.Rating,
		&i.LatestFileDate,
	)
	return i, err
}

const getAddonLatestFileDate = `-- name: GetAddonLatestFileDate :one
SELECT latest_file_date FROM addons WHERE id = $1
`

// Gets the latest file date for maintenance multiplier
func (q *Queries) GetAddonLatestFileDate(ctx context.Context, id int32) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getAddonLatestFileDate, id)
	var latest_file_date pgtype.Timestamptz
	err := row.Scan(&latest_file_date)
	return latest_file_date, err
}

const getAddonSnapshots = `-- name: GetAddonSnapshots :many
SELECT recorded_at, download_count, thumbs_up_count, popularity_rank
FROM snapshots
WHERE addon_id = $1
ORDER BY recorded_at DESC
LIMIT $2
`

type GetAddonSnapshotsParams struct {
	AddonID int32 `json:"addon_id"`
	Limit   int32 `json:"limit"`
}

type GetAddonSnapshotsRow struct {
	RecordedAt     pgtype.Timestamptz `json:"recorded_at"`
	DownloadCount  int64              `json:"download_count"`
	ThumbsUpCount  pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank pgtype.Int4        `json:"popularity_rank"`
}

func (q *Queries) GetAddonSnapshots(ctx context.Context, arg GetAddonSnapshotsParams) ([]GetAddonSnapshotsRow, error) {
	rows, err := q.db.Query(ctx, getAddonSnapshots, arg.AddonID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAddonSnapshotsRow{}
	for rows.Next() {
		var i GetAddonSnapshotsRow
		if err := rows.Scan(
			&i.RecordedAt,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAddonIDs = `-- name: GetAllAddonIDs :many
SELECT id FROM addons WHERE status = 'active'
`

func (q *Queries) GetAllAddonIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getAllAddonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSnapshotStats = `-- name: GetAllSnapshotStats :many
WITH stats_24h AS (
    SELECT
        addon_id,
        COALESCE(MAX(download_count) - MIN(download_count), 0)::bigint AS download_change,
        COALESCE(MAX(thumbs_up_count) - MIN(thumbs_up_count), 0)::int AS thumbs_change,
        COUNT(*)::int AS snapshot_count,
        MIN(download_count)::bigint AS min_downloads
    FROM snapshots
    WHERE recorded_at >= NOW() - INTERVAL '24 hours'
    GROUP BY addon_id
),
stats_7d AS (
    SELECT
        addon_id,
        COALESCE(MAX(download_count) - MIN(download_count), 0)::bigint AS download_change,
        COALESCE(MAX(thumbs_up_count) - MIN(thumbs_up_count), 0)::int AS thumbs_change,
        MIN(download_count)::bigint AS min_downloads
    FROM snapshots
    WHERE recorded_at >= NOW() - INTERVAL '7 days'
    GROUP BY addon_id
)
SELECT
    a.id AS addon_id,
    a.download_count,
    a.thumbs_up_count,
    a.latest_file_date,
    a.created_at,
    COALESCE(s24.download_change, 0) AS download_change_24h,
    COALESCE(s24.thumbs_change, 0) AS thumbs_change_24h,
    COALESCE(s24.snapshot_count, 0) AS snapshot_count_24h,
    COALESCE(s7.download_change, 0) AS download_change_7d,
    COALESCE(s7.thumbs_change, 0) AS thumbs_change_7d,
    COALESCE(s7.min_downloads, a.download_count) AS min_downloads_7d
FROM addons a
LEFT JOIN stats_24h s24 ON a.id = s24.addon_id
LEFT JOIN stats_7d s7 ON a.id = s7.addon_id
WHERE a.status = 'active'
`

type GetAllSnapshotStatsRow struct {
	AddonID           int32              `json:"addon_id"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	DownloadChange24h int64              `json:"download_change_24h"`
	ThumbsChange24h   int32              `json:"thumbs_change_24h"`
	SnapshotCount24h  int32              `json:"snapshot_count_24h"`
	DownloadChange7d  int64              `json:"download_change_7d"`
	ThumbsChange7d    int32              `json:"thumbs_change_7d"`
	MinDownloads7d    int64              `json:"min_downloads_7d"`
}

// Bulk fetch snapshot stats for all addons in both time windows
func (q *Queries) GetAllSnapshotStats(ctx context.Context) ([]GetAllSnapshotStatsRow, error) {
	rows, err := q.db.Query(ctx, getAllSnapshotStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSnapshotStatsRow{}
	for rows.Next() {
		var i GetAllSnapshotStatsRow
		if err := rows.Scan(
			&i.AddonID,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.LatestFileDate,
			&i.CreatedAt,
			&i.DownloadChange24h,
			&i.ThumbsChange24h,
			&i.SnapshotCount24h,
			&i.DownloadChange7d,
			&i.ThumbsChange7d,
			&i.MinDownloads7d,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTrendingScores = `-- name: GetAllTrendingScores :many
SELECT addon_id, first_hot_at, first_rising_at
FROM trending_scores
`

type GetAllTrendingScoresRow struct {
	AddonID       int32              `json:"addon_id"`
	FirstHotAt    pgtype.Timestamptz `json:"first_hot_at"`
	FirstRisingAt pgtype.Timestamptz `json:"first_rising_at"`
}

// Bulk fetch all existing trending scores
func (q *Queries) GetAllTrendingScores(ctx context.Context) ([]GetAllTrendingScoresRow, error) {
	rows, err := q.db.Query(ctx, getAllTrendingScores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTrendingScoresRow{}
	for rows.Next() {
		var i GetAllTrendingScoresRow
		if err := rows.Scan(&i.AddonID, &i.FirstHotAt, &i.FirstRisingAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, parent_id, icon_url FROM categories WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ParentID,
		&i.IconUrl,
	)
	return i, err
}

const getDownloadPercentile = `-- name: GetDownloadPercentile :one
SELECT COALESCE(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY download_count), 500000)::FLOAT8 AS percentile_95
FROM addons
WHERE status = 'active' AND download_count > 0
`

// Gets the Nth percentile of total downloads for size multiplier calculation
func (q *Queries) GetDownloadPercentile(ctx context.Context) (float64, error) {
	row := q.db.QueryRow(ctx, getDownloadPercentile)
	var percentile_95 float64
	err := row.Scan(&percentile_95)
	return percentile_95, err
}

const getHotAddonIDs = `-- name: GetHotAddonIDs :many
SELECT id FROM addons WHERE is_hot = TRUE AND status = 'active'
`

func (q *Queries) GetHotAddonIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getHotAddonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRankAt = `-- name: GetRankAt :one
SELECT rank FROM trending_rank_history
WHERE addon_id = $1
  AND category = $2
  AND recorded_at <= $3
ORDER BY recorded_at DESC
LIMIT 1
`

type GetRankAtParams struct {
	AddonID    int32              `json:"addon_id"`
	Category   string             `json:"category"`
	RecordedAt pgtype.Timestamptz `json:"recorded_at"`
}

// Get the rank of an addon at a specific time (closest record before that time)
func (q *Queries) GetRankAt(ctx context.Context, arg GetRankAtParams) (int16, error) {
	row := q.db.QueryRow(ctx, getRankAt, arg.AddonID, arg.Category, arg.RecordedAt)
	var rank int16
	err := row.Scan(&rank)
	return rank, err
}

const getRankChanges = `-- name: GetRankChanges :many
WITH current_ranks AS (
    -- Use DISTINCT ON to get most recent rank per addon/category
    -- (each INSERT has a slightly different microsecond timestamp)
    SELECT DISTINCT ON (addon_id, category) addon_id, category, rank, score
    FROM trending_rank_history
    ORDER BY addon_id, category, recorded_at DESC
),
ranks_24h AS (
    SELECT DISTINCT ON (addon_id, category) addon_id, category, rank
    FROM trending_rank_history
    WHERE recorded_at <= NOW() - INTERVAL '24 hours'
    ORDER BY addon_id, category, recorded_at DESC
),
ranks_7d AS (
    SELECT DISTINCT ON (addon_id, category) addon_id, category, rank
    FROM trending_rank_history
    WHERE recorded_at <= NOW() - INTERVAL '7 days'
    ORDER BY addon_id, category, recorded_at DESC
)
SELECT
    c.addon_id,
    c.category,
    c.rank AS current_rank,
    c.score,
    r24.rank AS rank_24h_ago,
    r7.rank AS rank_7d_ago
FROM current_ranks c
LEFT JOIN ranks_24h r24 ON c.addon_id = r24.addon_id AND c.category = r24.category
LEFT JOIN ranks_7d r7 ON c.addon_id = r7.addon_id AND c.category = r7.category
`

type GetRankChangesRow struct {
	AddonID     int32          `json:"addon_id"`
	Category    string         `json:"category"`
	CurrentRank int16          `json:"current_rank"`
	Score       pgtype.Numeric `json:"score"`
	Rank24hAgo  pgtype.Int2    `json:"rank_24h_ago"`
	Rank7dAgo   pgtype.Int2    `json:"rank_7d_ago"`
}

// Get rank changes for top addons (24h and 7d ago)
func (q *Queries) GetRankChanges(ctx context.Context) ([]GetRankChangesRow, error) {
	rows, err := q.db.Query(ctx, getRankChanges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRankChangesRow{}
	for rows.Next() {
		var i GetRankChangesRow
		if err := rows.Scan(
			&i.AddonID,
			&i.Category,
			&i.CurrentRank,
			&i.Score,
			&i.Rank24hAgo,
			&i.Rank7dAgo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnapshotStats = `-- name: GetSnapshotStats :one
SELECT
    COALESCE(MAX(download_count) - MIN(download_count), 0) AS download_change,
    COALESCE(MAX(thumbs_up_count) - MIN(thumbs_up_count), 0) AS thumbs_change,
    COUNT(*) AS snapshot_count,
    MIN(download_count) AS min_downloads,
    MAX(download_count) AS max_downloads
FROM snapshots
WHERE addon_id = $1
  AND recorded_at >= NOW() - ($2 || ' hours')::INTERVAL
`

type GetSnapshotStatsParams struct {
	AddonID int32       `json:"addon_id"`
	Column2 pgtype.Text `json:"column_2"`
}

type GetSnapshotStatsRow struct {
	DownloadChange interface{} `json:"download_change"`
	ThumbsChange   interface{} `json:"thumbs_change"`
	SnapshotCount  int64       `json:"snapshot_count"`
	MinDownloads   interface{} `json:"min_downloads"`
	MaxDownloads   interface{} `json:"max_downloads"`
}

// Gets download/thumbs changes for velocity calculation
func (q *Queries) GetSnapshotStats(ctx context.Context, arg GetSnapshotStatsParams) (GetSnapshotStatsRow, error) {
	row := q.db.QueryRow(ctx, getSnapshotStats, arg.AddonID, arg.Column2)
	var i GetSnapshotStatsRow
	err := row.Scan(
		&i.DownloadChange,
		&i.ThumbsChange,
		&i.SnapshotCount,
		&i.MinDownloads,
		&i.MaxDownloads,
	)
	return i, err
}

const getTrendingScore = `-- name: GetTrendingScore :one
SELECT addon_id, hot_score, rising_score, download_velocity, thumbs_velocity, download_growth_pct, thumbs_growth_pct, size_multiplier, maintenance_multiplier, first_hot_at, first_rising_at, calculated_at FROM trending_scores WHERE addon_id = $1
`

func (q *Queries) GetTrendingScore(ctx context.Context, addonID int32) (TrendingScore, error) {
	row := q.db.QueryRow(ctx, getTrendingScore, addonID)
	var i TrendingScore
	err := row.Scan(
		&i.AddonID,
		&i.HotScore,
		&i.RisingScore,
		&i.DownloadVelocity,
		&i.ThumbsVelocity,
		&i.DownloadGrowthPct,
		&i.ThumbsGrowthPct,
		&i.SizeMultiplier,
		&i.MaintenanceMultiplier,
		&i.FirstHotAt,
		&i.FirstRisingAt,
		&i.CalculatedAt,
	)
	return i, err
}

const insertRankHistory = `-- name: InsertRankHistory :exec
INSERT INTO trending_rank_history (addon_id, category, rank, score, recorded_at)
VALUES ($1, $2, $3, $4, NOW())
`

type InsertRankHistoryParams struct {
	AddonID  int32          `json:"addon_id"`
	Category string         `json:"category"`
	Rank     int16          `json:"rank"`
	Score    pgtype.Numeric `json:"score"`
}

// Record current rank for an addon in a category (deprecated: use InsertRankHistoryWithTime)
func (q *Queries) InsertRankHistory(ctx context.Context, arg InsertRankHistoryParams) error {
	_, err := q.db.Exec(ctx, insertRankHistory,
		arg.AddonID,
		arg.Category,
		arg.Rank,
		arg.Score,
	)
	return err
}

const insertRankHistoryWithTime = `-- name: InsertRankHistoryWithTime :exec
INSERT INTO trending_rank_history (addon_id, category, rank, score, recorded_at)
VALUES ($1, $2, $3, $4, $5)
`

type InsertRankHistoryWithTimeParams struct {
	AddonID    int32              `json:"addon_id"`
	Category   string             `json:"category"`
	Rank       int16              `json:"rank"`
	Score      pgtype.Numeric     `json:"score"`
	RecordedAt pgtype.Timestamptz `json:"recorded_at"`
}

// Record current rank with explicit timestamp (use for batch consistency)
func (q *Queries) InsertRankHistoryWithTime(ctx context.Context, arg InsertRankHistoryWithTimeParams) error {
	_, err := q.db.Exec(ctx, insertRankHistoryWithTime,
		arg.AddonID,
		arg.Category,
		arg.Rank,
		arg.Score,
		arg.RecordedAt,
	)
	return err
}

const listAddons = `-- name: ListAddons :many
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons
WHERE status = 'active'
ORDER BY download_count DESC
LIMIT $1 OFFSET $2
`

type ListAddonsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAddons(ctx context.Context, arg ListAddonsParams) ([]Addon, error) {
	rows, err := q.db.Query(ctx, listAddons, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Addon{}
	for rows.Next() {
		var i Addon
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAddonsByCategory = `-- name: ListAddonsByCategory :many
SELECT a.id, a.name, a.slug, a.summary, a.author_name, a.author_id, a.logo_url, a.primary_category_id, a.categories, a.game_versions, a.created_at, a.last_updated_at, a.last_synced_at, a.is_hot, a.hot_until, a.status, a.download_count, a.thumbs_up_count, a.popularity_rank, a.rating, a.latest_file_date FROM addons a
WHERE a.status = 'active'
  AND $3::int = ANY(a.categories)
ORDER BY a.download_count DESC
LIMIT $1 OFFSET $2
`

type ListAddonsByCategoryParams struct {
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
	Column3 int32 `json:"column_3"`
}

func (q *Queries) ListAddonsByCategory(ctx context.Context, arg ListAddonsByCategoryParams) ([]Addon, error) {
	rows, err := q.db.Query(ctx, listAddonsByCategory, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Addon{}
	for rows.Next() {
		var i Addon
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAddonsForTrendingCalc = `-- name: ListAddonsForTrendingCalc :many
SELECT id, download_count, thumbs_up_count, latest_file_date, created_at
FROM addons
WHERE status = 'active'
`

type ListAddonsForTrendingCalcRow struct {
	ID             int32              `json:"id"`
	DownloadCount  pgtype.Int8        `json:"download_count"`
	ThumbsUpCount  pgtype.Int4        `json:"thumbs_up_count"`
	LatestFileDate pgtype.Timestamptz `json:"latest_file_date"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

// Get addons with basic info needed for trending calculation
func (q *Queries) ListAddonsForTrendingCalc(ctx context.Context) ([]ListAddonsForTrendingCalcRow, error) {
	rows, err := q.db.Query(ctx, listAddonsForTrendingCalc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAddonsForTrendingCalcRow{}
	for rows.Next() {
		var i ListAddonsForTrendingCalcRow
		if err := rows.Scan(
			&i.ID,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.LatestFileDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, slug, parent_id, icon_url FROM categories ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ParentID,
			&i.IconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHotAddons = `-- name: ListHotAddons :many
SELECT a.id, a.name, a.slug, a.summary, a.author_name, a.author_id, a.logo_url, a.primary_category_id, a.categories, a.game_versions, a.created_at, a.last_updated_at, a.last_synced_at, a.is_hot, a.hot_until, a.status, a.download_count, a.thumbs_up_count, a.popularity_rank, a.rating, a.latest_file_date, t.hot_score, t.download_velocity
FROM addons a
JOIN trending_scores t ON a.id = t.addon_id
WHERE a.status = 'active'
  AND a.download_count >= 500
  AND t.hot_score > 0
ORDER BY t.hot_score DESC
LIMIT $1
`

type ListHotAddonsRow struct {
	ID                int32              `json:"id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	Summary           pgtype.Text        `json:"summary"`
	AuthorName        pgtype.Text        `json:"author_name"`
	AuthorID          pgtype.Int4        `json:"author_id"`
	LogoUrl           pgtype.Text        `json:"logo_url"`
	PrimaryCategoryID pgtype.Int4        `json:"primary_category_id"`
	Categories        []int32            `json:"categories"`
	GameVersions      []string           `json:"game_versions"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastUpdatedAt     pgtype.Timestamptz `json:"last_updated_at"`
	LastSyncedAt      pgtype.Timestamptz `json:"last_synced_at"`
	IsHot             pgtype.Bool        `json:"is_hot"`
	HotUntil          pgtype.Timestamptz `json:"hot_until"`
	Status            pgtype.Text        `json:"status"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank    pgtype.Int4        `json:"popularity_rank"`
	Rating            pgtype.Numeric     `json:"rating"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
	HotScore          pgtype.Numeric     `json:"hot_score"`
	DownloadVelocity  pgtype.Numeric     `json:"download_velocity"`
}

func (q *Queries) ListHotAddons(ctx context.Context, limit int32) ([]ListHotAddonsRow, error) {
	rows, err := q.db.Query(ctx, listHotAddons, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListHotAddonsRow{}
	for rows.Next() {
		var i ListHotAddonsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
			&i.HotScore,
			&i.DownloadVelocity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHotAddonsPaginated = `-- name: ListHotAddonsPaginated :many
SELECT a.id, a.name, a.slug, a.summary, a.author_name, a.author_id, a.logo_url, a.primary_category_id, a.categories, a.game_versions, a.created_at, a.last_updated_at, a.last_synced_at, a.is_hot, a.hot_until, a.status, a.download_count, a.thumbs_up_count, a.popularity_rank, a.rating, a.latest_file_date, t.hot_score, t.download_velocity
FROM addons a
JOIN trending_scores t ON a.id = t.addon_id
WHERE a.status = 'active'
  AND a.download_count >= 500
  AND t.hot_score > 0
ORDER BY t.hot_score DESC
LIMIT $1 OFFSET $2
`

type ListHotAddonsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListHotAddonsPaginatedRow struct {
	ID                int32              `json:"id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	Summary           pgtype.Text        `json:"summary"`
	AuthorName        pgtype.Text        `json:"author_name"`
	AuthorID          pgtype.Int4        `json:"author_id"`
	LogoUrl           pgtype.Text        `json:"logo_url"`
	PrimaryCategoryID pgtype.Int4        `json:"primary_category_id"`
	Categories        []int32            `json:"categories"`
	GameVersions      []string           `json:"game_versions"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastUpdatedAt     pgtype.Timestamptz `json:"last_updated_at"`
	LastSyncedAt      pgtype.Timestamptz `json:"last_synced_at"`
	IsHot             pgtype.Bool        `json:"is_hot"`
	HotUntil          pgtype.Timestamptz `json:"hot_until"`
	Status            pgtype.Text        `json:"status"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank    pgtype.Int4        `json:"popularity_rank"`
	Rating            pgtype.Numeric     `json:"rating"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
	HotScore          pgtype.Numeric     `json:"hot_score"`
	DownloadVelocity  pgtype.Numeric     `json:"download_velocity"`
}

func (q *Queries) ListHotAddonsPaginated(ctx context.Context, arg ListHotAddonsPaginatedParams) ([]ListHotAddonsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listHotAddonsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListHotAddonsPaginatedRow{}
	for rows.Next() {
		var i ListHotAddonsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
			&i.HotScore,
			&i.DownloadVelocity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRisingAddons = `-- name: ListRisingAddons :many
SELECT a.id, a.name, a.slug, a.summary, a.author_name, a.author_id, a.logo_url, a.primary_category_id, a.categories, a.game_versions, a.created_at, a.last_updated_at, a.last_synced_at, a.is_hot, a.hot_until, a.status, a.download_count, a.thumbs_up_count, a.popularity_rank, a.rating, a.latest_file_date, t.rising_score, t.download_velocity
FROM addons a
JOIN trending_scores t ON a.id = t.addon_id
WHERE a.status = 'active'
  AND a.download_count >= 50
  AND a.download_count <= 10000
  AND t.rising_score > 0
  AND a.id NOT IN (
      SELECT addon_id FROM trending_scores
      WHERE hot_score > 0
      ORDER BY hot_score DESC
      LIMIT 20
  )
ORDER BY t.rising_score DESC
LIMIT $1
`

type ListRisingAddonsRow struct {
	ID                int32              `json:"id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	Summary           pgtype.Text        `json:"summary"`
	AuthorName        pgtype.Text        `json:"author_name"`
	AuthorID          pgtype.Int4        `json:"author_id"`
	LogoUrl           pgtype.Text        `json:"logo_url"`
	PrimaryCategoryID pgtype.Int4        `json:"primary_category_id"`
	Categories        []int32            `json:"categories"`
	GameVersions      []string           `json:"game_versions"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastUpdatedAt     pgtype.Timestamptz `json:"last_updated_at"`
	LastSyncedAt      pgtype.Timestamptz `json:"last_synced_at"`
	IsHot             pgtype.Bool        `json:"is_hot"`
	HotUntil          pgtype.Timestamptz `json:"hot_until"`
	Status            pgtype.Text        `json:"status"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank    pgtype.Int4        `json:"popularity_rank"`
	Rating            pgtype.Numeric     `json:"rating"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
	RisingScore       pgtype.Numeric     `json:"rising_score"`
	DownloadVelocity  pgtype.Numeric     `json:"download_velocity"`
}

func (q *Queries) ListRisingAddons(ctx context.Context, limit int32) ([]ListRisingAddonsRow, error) {
	rows, err := q.db.Query(ctx, listRisingAddons, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRisingAddonsRow{}
	for rows.Next() {
		var i ListRisingAddonsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
			&i.RisingScore,
			&i.DownloadVelocity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRisingAddonsPaginated = `-- name: ListRisingAddonsPaginated :many
SELECT a.id, a.name, a.slug, a.summary, a.author_name, a.author_id, a.logo_url, a.primary_category_id, a.categories, a.game_versions, a.created_at, a.last_updated_at, a.last_synced_at, a.is_hot, a.hot_until, a.status, a.download_count, a.thumbs_up_count, a.popularity_rank, a.rating, a.latest_file_date, t.rising_score, t.download_velocity
FROM addons a
JOIN trending_scores t ON a.id = t.addon_id
WHERE a.status = 'active'
  AND a.download_count >= 50
  AND a.download_count <= 10000
  AND t.rising_score > 0
  AND a.id NOT IN (
      SELECT addon_id FROM trending_scores
      WHERE hot_score > 0
      ORDER BY hot_score DESC
      LIMIT 20
  )
ORDER BY t.rising_score DESC
LIMIT $1 OFFSET $2
`

type ListRisingAddonsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListRisingAddonsPaginatedRow struct {
	ID                int32              `json:"id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	Summary           pgtype.Text        `json:"summary"`
	AuthorName        pgtype.Text        `json:"author_name"`
	AuthorID          pgtype.Int4        `json:"author_id"`
	LogoUrl           pgtype.Text        `json:"logo_url"`
	PrimaryCategoryID pgtype.Int4        `json:"primary_category_id"`
	Categories        []int32            `json:"categories"`
	GameVersions      []string           `json:"game_versions"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastUpdatedAt     pgtype.Timestamptz `json:"last_updated_at"`
	LastSyncedAt      pgtype.Timestamptz `json:"last_synced_at"`
	IsHot             pgtype.Bool        `json:"is_hot"`
	HotUntil          pgtype.Timestamptz `json:"hot_until"`
	Status            pgtype.Text        `json:"status"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank    pgtype.Int4        `json:"popularity_rank"`
	Rating            pgtype.Numeric     `json:"rating"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
	RisingScore       pgtype.Numeric     `json:"rising_score"`
	DownloadVelocity  pgtype.Numeric     `json:"download_velocity"`
}

func (q *Queries) ListRisingAddonsPaginated(ctx context.Context, arg ListRisingAddonsPaginatedParams) ([]ListRisingAddonsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listRisingAddonsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRisingAddonsPaginatedRow{}
	for rows.Next() {
		var i ListRisingAddonsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
			&i.RisingScore,
			&i.DownloadVelocity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMissingAddonsInactive = `-- name: MarkMissingAddonsInactive :execrows
WITH synced_ids AS (SELECT unnest($1::integer[]) AS id)
UPDATE addons
SET status = 'inactive', last_synced_at = NOW()
WHERE status = 'active'
  AND NOT EXISTS (SELECT 1 FROM synced_ids WHERE synced_ids.id = addons.id)
`

// Mark addons as inactive if they no longer appear in CurseForge API response
func (q *Queries) MarkMissingAddonsInactive(ctx context.Context, dollar_1 []int32) (int64, error) {
	result, err := q.db.Exec(ctx, markMissingAddonsInactive, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const searchAddons = `-- name: SearchAddons :many
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons
WHERE status = 'active'
  AND (name ILIKE '%' || $3 || '%' OR summary ILIKE '%' || $3 || '%')
ORDER BY download_count DESC
LIMIT $1 OFFSET $2
`

type SearchAddonsParams struct {
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	Column3 pgtype.Text `json:"column_3"`
}

func (q *Queries) SearchAddons(ctx context.Context, arg SearchAddonsParams) ([]Addon, error) {
	rows, err := q.db.Query(ctx, searchAddons, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Addon{}
	for rows.Next() {
		var i Addon
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAddon = `-- name: UpsertAddon :exec
INSERT INTO addons (
    id, name, slug, summary, author_name, author_id, logo_url,
    primary_category_id, categories, game_versions,
    created_at, last_updated_at, last_synced_at,
    download_count, thumbs_up_count, popularity_rank, rating, latest_file_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), $13, $14, $15, $16, $17
)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    summary = EXCLUDED.summary,
    author_name = EXCLUDED.author_name,
    author_id = EXCLUDED.author_id,
    logo_url = EXCLUDED.logo_url,
    primary_category_id = EXCLUDED.primary_category_id,
    categories = EXCLUDED.categories,
    game_versions = EXCLUDED.game_versions,
    last_updated_at = EXCLUDED.last_updated_at,
    last_synced_at = NOW(),
    download_count = EXCLUDED.download_count,
    thumbs_up_count = EXCLUDED.thumbs_up_count,
    popularity_rank = EXCLUDED.popularity_rank,
    rating = EXCLUDED.rating,
    latest_file_date = EXCLUDED.latest_file_date,
    status = 'active'
`

type UpsertAddonParams struct {
	ID                int32              `json:"id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	Summary           pgtype.Text        `json:"summary"`
	AuthorName        pgtype.Text        `json:"author_name"`
	AuthorID          pgtype.Int4        `json:"author_id"`
	LogoUrl           pgtype.Text        `json:"logo_url"`
	PrimaryCategoryID pgtype.Int4        `json:"primary_category_id"`
	Categories        []int32            `json:"categories"`
	GameVersions      []string           `json:"game_versions"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastUpdatedAt     pgtype.Timestamptz `json:"last_updated_at"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank    pgtype.Int4        `json:"popularity_rank"`
	Rating            pgtype.Numeric     `json:"rating"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
}

func (q *Queries) UpsertAddon(ctx context.Context, arg UpsertAddonParams) error {
	_, err := q.db.Exec(ctx, upsertAddon,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Summary,
		arg.AuthorName,
		arg.AuthorID,
		arg.LogoUrl,
		arg.PrimaryCategoryID,
		arg.Categories,
		arg.GameVersions,
		arg.CreatedAt,
		arg.LastUpdatedAt,
		arg.DownloadCount,
		arg.ThumbsUpCount,
		arg.PopularityRank,
		arg.Rating,
		arg.LatestFileDate,
	)
	return err
}

const upsertCategory = `-- name: UpsertCategory :exec
INSERT INTO categories (id, name, slug, parent_id, icon_url)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    parent_id = EXCLUDED.parent_id,
    icon_url = EXCLUDED.icon_url
`

type UpsertCategoryParams struct {
	ID       int32       `json:"id"`
	Name     string      `json:"name"`
	Slug     string      `json:"slug"`
	ParentID pgtype.Int4 `json:"parent_id"`
	IconUrl  pgtype.Text `json:"icon_url"`
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) error {
	_, err := q.db.Exec(ctx, upsertCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ParentID,
		arg.IconUrl,
	)
	return err
}

const upsertTrendingScore = `-- name: UpsertTrendingScore :exec
INSERT INTO trending_scores (
    addon_id, hot_score, rising_score,
    download_velocity, thumbs_velocity,
    download_growth_pct, thumbs_growth_pct,
    size_multiplier, maintenance_multiplier,
    first_hot_at, first_rising_at, calculated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW())
ON CONFLICT (addon_id) DO UPDATE SET
    hot_score = EXCLUDED.hot_score,
    rising_score = EXCLUDED.rising_score,
    download_velocity = EXCLUDED.download_velocity,
    thumbs_velocity = EXCLUDED.thumbs_velocity,
    download_growth_pct = EXCLUDED.download_growth_pct,
    thumbs_growth_pct = EXCLUDED.thumbs_growth_pct,
    size_multiplier = EXCLUDED.size_multiplier,
    maintenance_multiplier = EXCLUDED.maintenance_multiplier,
    first_hot_at = COALESCE(EXCLUDED.first_hot_at, trending_scores.first_hot_at),
    first_rising_at = COALESCE(EXCLUDED.first_rising_at, trending_scores.first_rising_at),
    calculated_at = NOW()
`

type UpsertTrendingScoreParams struct {
	AddonID               int32              `json:"addon_id"`
	HotScore              pgtype.Numeric     `json:"hot_score"`
	RisingScore           pgtype.Numeric     `json:"rising_score"`
	DownloadVelocity      pgtype.Numeric     `json:"download_velocity"`
	ThumbsVelocity        pgtype.Numeric     `json:"thumbs_velocity"`
	DownloadGrowthPct     pgtype.Numeric     `json:"download_growth_pct"`
	ThumbsGrowthPct       pgtype.Numeric     `json:"thumbs_growth_pct"`
	SizeMultiplier        pgtype.Numeric     `json:"size_multiplier"`
	MaintenanceMultiplier pgtype.Numeric     `json:"maintenance_multiplier"`
	FirstHotAt            pgtype.Timestamptz `json:"first_hot_at"`
	FirstRisingAt         pgtype.Timestamptz `json:"first_rising_at"`
}

func (q *Queries) UpsertTrendingScore(ctx context.Context, arg UpsertTrendingScoreParams) error {
	_, err := q.db.Exec(ctx, upsertTrendingScore,
		arg.AddonID,
		arg.HotScore,
		arg.RisingScore,
		arg.DownloadVelocity,
		arg.ThumbsVelocity,
		arg.DownloadGrowthPct,
		arg.ThumbsGrowthPct,
		arg.SizeMultiplier,
		arg.MaintenanceMultiplier,
		arg.FirstHotAt,
		arg.FirstRisingAt,
	)
	return err
}
