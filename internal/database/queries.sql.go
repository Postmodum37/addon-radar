// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveAddons = `-- name: CountActiveAddons :one
SELECT COUNT(*) FROM addons WHERE status = 'active'
`

func (q *Queries) CountActiveAddons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveAddons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAddons = `-- name: CountAddons :one
SELECT COUNT(*) FROM addons WHERE status = 'active'
`

func (q *Queries) CountAddons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAddons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAddonsByCategory = `-- name: CountAddonsByCategory :one
SELECT COUNT(*) FROM addons
WHERE status = 'active'
  AND $1 = ANY(categories)
`

func (q *Queries) CountAddonsByCategory(ctx context.Context, categories []int32) (int64, error) {
	row := q.db.QueryRow(ctx, countAddonsByCategory, categories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchAddons = `-- name: CountSearchAddons :one
SELECT COUNT(*) FROM addons
WHERE status = 'active'
  AND (name ILIKE '%' || $1 || '%' OR summary ILIKE '%' || $1 || '%')
`

func (q *Queries) CountSearchAddons(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchAddons, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSnapshots = `-- name: CountSnapshots :one
SELECT COUNT(*) FROM snapshots
`

func (q *Queries) CountSnapshots(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSnapshots)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSnapshot = `-- name: CreateSnapshot :exec
INSERT INTO snapshots (addon_id, recorded_at, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date)
VALUES ($1, NOW(), $2, $3, $4, $5, $6)
`

type CreateSnapshotParams struct {
	AddonID        int32              `json:"addon_id"`
	DownloadCount  int64              `json:"download_count"`
	ThumbsUpCount  pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank pgtype.Int4        `json:"popularity_rank"`
	Rating         pgtype.Numeric     `json:"rating"`
	LatestFileDate pgtype.Timestamptz `json:"latest_file_date"`
}

func (q *Queries) CreateSnapshot(ctx context.Context, arg CreateSnapshotParams) error {
	_, err := q.db.Exec(ctx, createSnapshot,
		arg.AddonID,
		arg.DownloadCount,
		arg.ThumbsUpCount,
		arg.PopularityRank,
		arg.Rating,
		arg.LatestFileDate,
	)
	return err
}

const getAddonByID = `-- name: GetAddonByID :one
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons WHERE id = $1
`

func (q *Queries) GetAddonByID(ctx context.Context, id int32) (Addon, error) {
	row := q.db.QueryRow(ctx, getAddonByID, id)
	var i Addon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Summary,
		&i.AuthorName,
		&i.AuthorID,
		&i.LogoUrl,
		&i.PrimaryCategoryID,
		&i.Categories,
		&i.GameVersions,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.LastSyncedAt,
		&i.IsHot,
		&i.HotUntil,
		&i.Status,
		&i.DownloadCount,
		&i.ThumbsUpCount,
		&i.PopularityRank,
		&i.Rating,
		&i.LatestFileDate,
	)
	return i, err
}

const getAddonBySlug = `-- name: GetAddonBySlug :one
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons WHERE slug = $1 AND status = 'active'
`

func (q *Queries) GetAddonBySlug(ctx context.Context, slug string) (Addon, error) {
	row := q.db.QueryRow(ctx, getAddonBySlug, slug)
	var i Addon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Summary,
		&i.AuthorName,
		&i.AuthorID,
		&i.LogoUrl,
		&i.PrimaryCategoryID,
		&i.Categories,
		&i.GameVersions,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.LastSyncedAt,
		&i.IsHot,
		&i.HotUntil,
		&i.Status,
		&i.DownloadCount,
		&i.ThumbsUpCount,
		&i.PopularityRank,
		&i.Rating,
		&i.LatestFileDate,
	)
	return i, err
}

const getAddonSnapshots = `-- name: GetAddonSnapshots :many
SELECT recorded_at, download_count, thumbs_up_count, popularity_rank
FROM snapshots
WHERE addon_id = $1
ORDER BY recorded_at DESC
LIMIT $2
`

type GetAddonSnapshotsParams struct {
	AddonID int32 `json:"addon_id"`
	Limit   int32 `json:"limit"`
}

type GetAddonSnapshotsRow struct {
	RecordedAt     pgtype.Timestamptz `json:"recorded_at"`
	DownloadCount  int64              `json:"download_count"`
	ThumbsUpCount  pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank pgtype.Int4        `json:"popularity_rank"`
}

func (q *Queries) GetAddonSnapshots(ctx context.Context, arg GetAddonSnapshotsParams) ([]GetAddonSnapshotsRow, error) {
	rows, err := q.db.Query(ctx, getAddonSnapshots, arg.AddonID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAddonSnapshotsRow{}
	for rows.Next() {
		var i GetAddonSnapshotsRow
		if err := rows.Scan(
			&i.RecordedAt,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAddonIDs = `-- name: GetAllAddonIDs :many
SELECT id FROM addons WHERE status = 'active'
`

func (q *Queries) GetAllAddonIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getAllAddonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, parent_id, icon_url FROM categories WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ParentID,
		&i.IconUrl,
	)
	return i, err
}

const getHotAddonIDs = `-- name: GetHotAddonIDs :many
SELECT id FROM addons WHERE is_hot = TRUE AND status = 'active'
`

func (q *Queries) GetHotAddonIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getHotAddonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAddons = `-- name: ListAddons :many
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons
WHERE status = 'active'
ORDER BY download_count DESC
LIMIT $1 OFFSET $2
`

type ListAddonsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAddons(ctx context.Context, arg ListAddonsParams) ([]Addon, error) {
	rows, err := q.db.Query(ctx, listAddons, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Addon{}
	for rows.Next() {
		var i Addon
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAddonsByCategory = `-- name: ListAddonsByCategory :many
SELECT a.id, a.name, a.slug, a.summary, a.author_name, a.author_id, a.logo_url, a.primary_category_id, a.categories, a.game_versions, a.created_at, a.last_updated_at, a.last_synced_at, a.is_hot, a.hot_until, a.status, a.download_count, a.thumbs_up_count, a.popularity_rank, a.rating, a.latest_file_date FROM addons a
WHERE a.status = 'active'
  AND $3 = ANY(a.categories)
ORDER BY a.download_count DESC
LIMIT $1 OFFSET $2
`

type ListAddonsByCategoryParams struct {
	Limit      int32   `json:"limit"`
	Offset     int32   `json:"offset"`
	Categories []int32 `json:"categories"`
}

func (q *Queries) ListAddonsByCategory(ctx context.Context, arg ListAddonsByCategoryParams) ([]Addon, error) {
	rows, err := q.db.Query(ctx, listAddonsByCategory, arg.Limit, arg.Offset, arg.Categories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Addon{}
	for rows.Next() {
		var i Addon
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, slug, parent_id, icon_url FROM categories ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ParentID,
			&i.IconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAddons = `-- name: SearchAddons :many
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons
WHERE status = 'active'
  AND (name ILIKE '%' || $3 || '%' OR summary ILIKE '%' || $3 || '%')
ORDER BY download_count DESC
LIMIT $1 OFFSET $2
`

type SearchAddonsParams struct {
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	Column3 pgtype.Text `json:"column_3"`
}

func (q *Queries) SearchAddons(ctx context.Context, arg SearchAddonsParams) ([]Addon, error) {
	rows, err := q.db.Query(ctx, searchAddons, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Addon{}
	for rows.Next() {
		var i Addon
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Summary,
			&i.AuthorName,
			&i.AuthorID,
			&i.LogoUrl,
			&i.PrimaryCategoryID,
			&i.Categories,
			&i.GameVersions,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.LastSyncedAt,
			&i.IsHot,
			&i.HotUntil,
			&i.Status,
			&i.DownloadCount,
			&i.ThumbsUpCount,
			&i.PopularityRank,
			&i.Rating,
			&i.LatestFileDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAddon = `-- name: UpsertAddon :exec
INSERT INTO addons (
    id, name, slug, summary, author_name, author_id, logo_url,
    primary_category_id, categories, game_versions,
    created_at, last_updated_at, last_synced_at,
    download_count, thumbs_up_count, popularity_rank, rating, latest_file_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), $13, $14, $15, $16, $17
)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    summary = EXCLUDED.summary,
    author_name = EXCLUDED.author_name,
    author_id = EXCLUDED.author_id,
    logo_url = EXCLUDED.logo_url,
    primary_category_id = EXCLUDED.primary_category_id,
    categories = EXCLUDED.categories,
    game_versions = EXCLUDED.game_versions,
    last_updated_at = EXCLUDED.last_updated_at,
    last_synced_at = NOW(),
    download_count = EXCLUDED.download_count,
    thumbs_up_count = EXCLUDED.thumbs_up_count,
    popularity_rank = EXCLUDED.popularity_rank,
    rating = EXCLUDED.rating,
    latest_file_date = EXCLUDED.latest_file_date
`

type UpsertAddonParams struct {
	ID                int32              `json:"id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	Summary           pgtype.Text        `json:"summary"`
	AuthorName        pgtype.Text        `json:"author_name"`
	AuthorID          pgtype.Int4        `json:"author_id"`
	LogoUrl           pgtype.Text        `json:"logo_url"`
	PrimaryCategoryID pgtype.Int4        `json:"primary_category_id"`
	Categories        []int32            `json:"categories"`
	GameVersions      []string           `json:"game_versions"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastUpdatedAt     pgtype.Timestamptz `json:"last_updated_at"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank    pgtype.Int4        `json:"popularity_rank"`
	Rating            pgtype.Numeric     `json:"rating"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
}

func (q *Queries) UpsertAddon(ctx context.Context, arg UpsertAddonParams) error {
	_, err := q.db.Exec(ctx, upsertAddon,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Summary,
		arg.AuthorName,
		arg.AuthorID,
		arg.LogoUrl,
		arg.PrimaryCategoryID,
		arg.Categories,
		arg.GameVersions,
		arg.CreatedAt,
		arg.LastUpdatedAt,
		arg.DownloadCount,
		arg.ThumbsUpCount,
		arg.PopularityRank,
		arg.Rating,
		arg.LatestFileDate,
	)
	return err
}

const upsertCategory = `-- name: UpsertCategory :exec
INSERT INTO categories (id, name, slug, parent_id, icon_url)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    parent_id = EXCLUDED.parent_id,
    icon_url = EXCLUDED.icon_url
`

type UpsertCategoryParams struct {
	ID       int32       `json:"id"`
	Name     string      `json:"name"`
	Slug     string      `json:"slug"`
	ParentID pgtype.Int4 `json:"parent_id"`
	IconUrl  pgtype.Text `json:"icon_url"`
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) error {
	_, err := q.db.Exec(ctx, upsertCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ParentID,
		arg.IconUrl,
	)
	return err
}
