// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAddons = `-- name: CountAddons :one
SELECT COUNT(*) FROM addons WHERE status = 'active'
`

func (q *Queries) CountAddons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAddons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSnapshots = `-- name: CountSnapshots :one
SELECT COUNT(*) FROM snapshots
`

func (q *Queries) CountSnapshots(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSnapshots)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSnapshot = `-- name: CreateSnapshot :exec
INSERT INTO snapshots (addon_id, recorded_at, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date)
VALUES ($1, NOW(), $2, $3, $4, $5, $6)
`

type CreateSnapshotParams struct {
	AddonID        int32              `json:"addon_id"`
	DownloadCount  int64              `json:"download_count"`
	ThumbsUpCount  pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank pgtype.Int4        `json:"popularity_rank"`
	Rating         pgtype.Numeric     `json:"rating"`
	LatestFileDate pgtype.Timestamptz `json:"latest_file_date"`
}

func (q *Queries) CreateSnapshot(ctx context.Context, arg CreateSnapshotParams) error {
	_, err := q.db.Exec(ctx, createSnapshot,
		arg.AddonID,
		arg.DownloadCount,
		arg.ThumbsUpCount,
		arg.PopularityRank,
		arg.Rating,
		arg.LatestFileDate,
	)
	return err
}

const getAddonByID = `-- name: GetAddonByID :one
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons WHERE id = $1
`

func (q *Queries) GetAddonByID(ctx context.Context, id int32) (Addon, error) {
	row := q.db.QueryRow(ctx, getAddonByID, id)
	var i Addon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Summary,
		&i.AuthorName,
		&i.AuthorID,
		&i.LogoUrl,
		&i.PrimaryCategoryID,
		&i.Categories,
		&i.GameVersions,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.LastSyncedAt,
		&i.IsHot,
		&i.HotUntil,
		&i.Status,
		&i.DownloadCount,
		&i.ThumbsUpCount,
		&i.PopularityRank,
		&i.Rating,
		&i.LatestFileDate,
	)
	return i, err
}

const getAddonBySlug = `-- name: GetAddonBySlug :one
SELECT id, name, slug, summary, author_name, author_id, logo_url, primary_category_id, categories, game_versions, created_at, last_updated_at, last_synced_at, is_hot, hot_until, status, download_count, thumbs_up_count, popularity_rank, rating, latest_file_date FROM addons WHERE slug = $1
`

func (q *Queries) GetAddonBySlug(ctx context.Context, slug string) (Addon, error) {
	row := q.db.QueryRow(ctx, getAddonBySlug, slug)
	var i Addon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Summary,
		&i.AuthorName,
		&i.AuthorID,
		&i.LogoUrl,
		&i.PrimaryCategoryID,
		&i.Categories,
		&i.GameVersions,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.LastSyncedAt,
		&i.IsHot,
		&i.HotUntil,
		&i.Status,
		&i.DownloadCount,
		&i.ThumbsUpCount,
		&i.PopularityRank,
		&i.Rating,
		&i.LatestFileDate,
	)
	return i, err
}

const getAllAddonIDs = `-- name: GetAllAddonIDs :many
SELECT id FROM addons WHERE status = 'active'
`

func (q *Queries) GetAllAddonIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getAllAddonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHotAddonIDs = `-- name: GetHotAddonIDs :many
SELECT id FROM addons WHERE is_hot = TRUE AND status = 'active'
`

func (q *Queries) GetHotAddonIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getHotAddonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAddon = `-- name: UpsertAddon :exec
INSERT INTO addons (
    id, name, slug, summary, author_name, author_id, logo_url,
    primary_category_id, categories, game_versions,
    created_at, last_updated_at, last_synced_at,
    download_count, thumbs_up_count, popularity_rank, rating, latest_file_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), $13, $14, $15, $16, $17
)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    summary = EXCLUDED.summary,
    author_name = EXCLUDED.author_name,
    author_id = EXCLUDED.author_id,
    logo_url = EXCLUDED.logo_url,
    primary_category_id = EXCLUDED.primary_category_id,
    categories = EXCLUDED.categories,
    game_versions = EXCLUDED.game_versions,
    last_updated_at = EXCLUDED.last_updated_at,
    last_synced_at = NOW(),
    download_count = EXCLUDED.download_count,
    thumbs_up_count = EXCLUDED.thumbs_up_count,
    popularity_rank = EXCLUDED.popularity_rank,
    rating = EXCLUDED.rating,
    latest_file_date = EXCLUDED.latest_file_date
`

type UpsertAddonParams struct {
	ID                int32              `json:"id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	Summary           pgtype.Text        `json:"summary"`
	AuthorName        pgtype.Text        `json:"author_name"`
	AuthorID          pgtype.Int4        `json:"author_id"`
	LogoUrl           pgtype.Text        `json:"logo_url"`
	PrimaryCategoryID pgtype.Int4        `json:"primary_category_id"`
	Categories        []int32            `json:"categories"`
	GameVersions      []string           `json:"game_versions"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastUpdatedAt     pgtype.Timestamptz `json:"last_updated_at"`
	DownloadCount     pgtype.Int8        `json:"download_count"`
	ThumbsUpCount     pgtype.Int4        `json:"thumbs_up_count"`
	PopularityRank    pgtype.Int4        `json:"popularity_rank"`
	Rating            pgtype.Numeric     `json:"rating"`
	LatestFileDate    pgtype.Timestamptz `json:"latest_file_date"`
}

func (q *Queries) UpsertAddon(ctx context.Context, arg UpsertAddonParams) error {
	_, err := q.db.Exec(ctx, upsertAddon,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Summary,
		arg.AuthorName,
		arg.AuthorID,
		arg.LogoUrl,
		arg.PrimaryCategoryID,
		arg.Categories,
		arg.GameVersions,
		arg.CreatedAt,
		arg.LastUpdatedAt,
		arg.DownloadCount,
		arg.ThumbsUpCount,
		arg.PopularityRank,
		arg.Rating,
		arg.LatestFileDate,
	)
	return err
}

const upsertCategory = `-- name: UpsertCategory :exec
INSERT INTO categories (id, name, slug, parent_id, icon_url)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    parent_id = EXCLUDED.parent_id,
    icon_url = EXCLUDED.icon_url
`

type UpsertCategoryParams struct {
	ID       int32       `json:"id"`
	Name     string      `json:"name"`
	Slug     string      `json:"slug"`
	ParentID pgtype.Int4 `json:"parent_id"`
	IconUrl  pgtype.Text `json:"icon_url"`
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) error {
	_, err := q.db.Exec(ctx, upsertCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ParentID,
		arg.IconUrl,
	)
	return err
}
